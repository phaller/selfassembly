/*
 * Copyright (C) 2014 LAMP/EPFL
 * Copyright (C) 2014 Typesafe Inc. <http://www.typesafe.com>
 */
package selfassembly.examples.pickling

import language.experimental.macros

import scala.reflect.macros.blackbox.Context
import selfassembly.{Queryable, Query, AcyclicQuery}
import internal._

// purpose of this macro: implementation of genPickler[T]. i.e. the macro that is selected
// via implicit search and which initiates the process of generating a pickler for a given type T
// NOTE: dispatch is done elsewhere. picklers generated by genPickler[T] only know how to process T
// but not its subclasses or the types convertible to it!
trait PicklerMacros extends Query[Unit] {
  import internal._ // for isEffectivelyFinal

  def mkTrees[C <: Context with Singleton](c: C): Trees[C] =
    new Trees(c)

  class Trees[C <: Context with Singleton](override val c: C) extends super.Trees(c) {
    import c.universe._

    // need an operation that tells us how to go from a field value
    // to the value that we have to pass to the type class
    // fld -->  (fld, builder)
    override def inject(fieldValue: c.Tree): c.Tree =
      q"($fieldValue -> visitee._2)"

    override def project(param: c.Tree): c.Tree =
      q"$param._1"

    // for now, innerMostPickleLogic must use `b` as the name of the builder! (TODO)
    override def putField(getterLogic: Tree, innerMostPickleLogic: c.Tree, nameOfSubPicklee: c.TermName,
                          fieldNameString: String, fieldTpe: c.Type): c.Tree = {
      val builder = q"visitee._2"
      def wrap(pickleLogic: Tree) = q"""
        $builder.putField($fieldNameString, b => $pickleLogic)
      """
      wrap {
        if (fieldTpe.typeSymbol.isEffectivelyFinal) q"""
          b.hintStaticallyElidedType()
          val $nameOfSubPicklee: $fieldTpe = $getterLogic
          $innerMostPickleLogic
        """ else q"""
          val $nameOfSubPicklee: $fieldTpe = $getterLogic
          if ($nameOfSubPicklee == null || $nameOfSubPicklee.getClass == classOf[$fieldTpe]) b.hintDynamicallyElidedType() else ()
          $nameOfSubPicklee.pickleInto(b)
        """
      }
    }

    override def preInvoke(fieldTpe: c.Type): c.Tree = {
      val secondTree = if (fieldTpe.typeSymbol.isEffectivelyFinal)
        q"visitee._2.hintStaticallyElidedType()" else q""
      q"""
        visitee._2.hintTag(implicitly[selfassembly.examples.pickling.FastTypeTag[$fieldTpe]])
        $secondTree
      """
    }

    def combine(left: c.Expr[Unit], right: c.Expr[Unit]): c.Expr[Unit] =
      c.Expr(q"$left ; $right")

    def delimit(tpe: c.Type): (c.Expr[Unit], c.Expr[Unit], c.Expr[Unit]) = {
      val first = c.Expr(q"visitee._2.beginEntry(visitee._1)")
      (first, c.Expr(q"; {}"), c.Expr(q"visitee._2.endEntry()"))
    }
  }
}

// purpose of this macro: implementation of genUnpickler[T]. i.e., the macro that is selected via implicit
// search and which initiates the process of generating an unpickler for a given type T.
// NOTE: dispatch is done elsewhere. unpicklers generated by genUnpickler[T] only know how to process T
// but not its subclasses or the types convertible to it!
trait UnpicklerMacros extends AcyclicQuery[Any] {
  def mkTrees[C <: Context with Singleton](c: C) = new Trees(c)

  class Trees[C <: Context with Singleton](override val c: C) extends super.Trees(c) {
    import c.universe._

    override def fieldValueTree(name: String, tpe: c.Type, tpeOfTypeClass: c.Type): c.Tree =
      q"reader.readField($name).unpickle[$tpe]"

    override def compose(tpe: c.Type, acc: c.Expr[Any], separator: c.Expr[Any], fieldValues: List[c.Expr[Any]]): c.Expr[Any] =
      c.Expr[Any](q"$acc = new $tpe(..$fieldValues)") // create new instance

    def combine(left: c.Expr[Any], right: c.Expr[Any]): c.Expr[Any] = left

    def delimit(tpe: c.Type): (c.Expr[Any], c.Expr[Any], c.Expr[Any]) =
      (c.Expr(q"null"), c.Expr(q"null"), c.Expr(q"null"))
  }
}

// purpose of this macro: implementation of unpickle method on type Pickle, which does
// 1) dispatch to the correct unpickler based on the type of the input,
// 2) insert a call in the generated code to the genUnpickler macro (described above)
trait UnpickleMacros extends Macro {

  // TODO: currently this works with an assumption that sharing settings for unpickling are the same as for pickling
  // of course this might not be the case, so we should be able to read settings from the pickle itself
  // this is not going to be particularly pretty. unlike the fix for the runtime interpreter, this fix will be a bit of a shotgun one
  def pickleUnpickle[T: c.WeakTypeTag]: c.Tree = {
    import c.universe._
    val tpe = weakTypeOf[T]
    val pickleArg = c.prefix.tree
    q"""
      import scala.language.existentials
      import selfassembly.examples.pickling._
      import selfassembly.examples.pickling.internal._
      val pickle = $pickleArg
      val format = implicitly[${pickleFormatType(pickleArg)}]
      val reader = format.createReader(pickle, selfassembly.examples.pickling.internal.`package`.currentMirror)
      reader.unpickleTopLevel[$tpe]
    """
  }

  def readerUnpickle[T: c.WeakTypeTag]: c.Tree = {
    readerUnpickleHelper(false)
  }

  def readerUnpickleTopLevel[T: c.WeakTypeTag]: c.Tree = {
    readerUnpickleHelper(true)
  }

  def readerUnpickleHelper[T: c.WeakTypeTag](isTopLevel: Boolean = false): c.Tree = {
    import c.universe._
    import definitions._
    val tpe = weakTypeOf[T]
    val sym = tpe.typeSymbol
    val readerArg = c.prefix.tree

    def createUnpickler(tpe: Type) = q"implicitly[Unpickler[$tpe]]"
    def finalDispatch = {
      if (sym.isNotNullable) createUnpickler(tpe)
      else q"""
        val tag = selfassembly.examples.pickling.FastTypeTag(typeString)
        if (tag.key == selfassembly.examples.pickling.FastTypeTag.Null.key) ${createUnpickler(NullTpe)}
        else if (tag.key == selfassembly.examples.pickling.FastTypeTag.Ref.key) ${createUnpickler(RefTpe)}
        else ${createUnpickler(tpe)}
      """
    }

    val customDispatch = CaseDef(Ident(nme.WILDCARD), EmptyTree, q"customUnpickler")
    val refDispatch = CaseDef(Literal(Constant(FastTypeTag.Ref.key)), EmptyTree, createUnpickler(typeOf[refs.Ref]))

    def nonFinalDispatch = {
      val compileTimeDispatch = compileTimeDispatchees(tpe) map (subtpe => {
        // TODO: do we still want to use something like HasPicklerDispatch (for unpicklers it would be routed throw tpe's companion)?
        CaseDef(Literal(Constant(subtpe.key)), EmptyTree, createUnpickler(subtpe))
      })
      val runtimeDispatch = CaseDef(Ident(nme.WILDCARD), EmptyTree, q"""
        val tag = selfassembly.examples.pickling.FastTypeTag(typeString)
        Unpickler.genUnpickler(reader.mirror, tag)
      """)

      q"""
        val customUnpickler = implicitly[Unpickler[$tpe]]
        if (customUnpickler.isInstanceOf[PicklerUnpicklerNotFound[_]] || customUnpickler.isInstanceOf[Generated]) {
          ${Match(q"typeString", compileTimeDispatch :+ refDispatch :+ runtimeDispatch)}
        } else {
          ${Match(q"typeString", List(refDispatch) :+ customDispatch)}
        }
      """
    }

    def abstractTypeDispatch =
      q"""
        val customUnpickler = implicitly[Unpickler[$tpe]]
        ${Match(q"typeString", List(refDispatch) :+ customDispatch)}
      """

    val staticHint = if (sym.isEffectivelyFinal && !isTopLevel) (q"reader.hintStaticallyElidedType()": Tree) else q"";
    val dispatchLogic =
      if (sym.asType.isAbstractType) abstractTypeDispatch
      else if (sym.isEffectivelyFinal) finalDispatch
      else nonFinalDispatch
    val unpickleeCleanup = if (isTopLevel && shouldBotherAboutCleaning(tpe)) q"clearUnpicklees()" else q""

    q"""
      val reader = $readerArg
      reader.hintTag(implicitly[selfassembly.examples.pickling.FastTypeTag[$tpe]])
      $staticHint
      val typeString = reader.beginEntryNoTag()
      val unpickler = $dispatchLogic
      val result = unpickler.unpickle(({ selfassembly.examples.pickling.FastTypeTag(typeString) }, reader))
      reader.endEntry()
      $unpickleeCleanup
      result.asInstanceOf[$tpe]
    """
  }
}
